/*

    QuasiDipole: quasidipole.c

    Copyright (C) 2023  Johnathan K Burchill

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

// Transcribed into C from the fortran apexsh.f90 code by John Emmert and Art Richmond
// dated 13 Nov 2009, version 1.0
// Requires apexsh.dat file, generated by the fortran file with file access='stream' to 
// avoid extraneous bytes in "unformatted" fortran output.

#include "quasidipole.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <time.h>
#include <stdint.h>
#include <libgen.h>
#include <strings.h>

static int32_t nmax = 0;
static int32_t mmax = 0;
static int32_t nterm = 0;
static int32_t lmax = 0;
static int32_t nepoch = 0;
static int32_t ntermsh = 0;

static float *epochgrid = NULL;
static double *coeff0 = NULL;
static double *qcoeff0 = NULL;
static double *gcoeff0 = NULL;

static double *xqcoeff = NULL;
static double *yqcoeff = NULL;
static double *zqcoeff = NULL;
static double *xgcoeff = NULL;
static double *ygcoeff = NULL;
static double *zgcoeff = NULL;
static double *polynomq = NULL;
static double *polynomg = NULL;
static double *sphericalharmonics = NULL;
static double *anm = NULL;
static double *bnm = NULL;
static double *cm = NULL;
static double *dnm = NULL;
static double *en = NULL;
static double *marr = NULL;
static double *narr = NULL;
static double *pbar = NULL;
static double *vbar = NULL;
static double *wbar = NULL;

#define Req 6378.1370
#define eps 1.0/298.257223563
#define Re (( Req * (1.0 - eps/3.0) ))
#define ecc2 (( eps * (2.0 - eps) ))

int initQuasiDipleCoefficients(char *filename, double dateAsYear)
{
    if (filename == NULL)
        return QD_NO_COEFF_FILENAME;

    static double coeffYear = 0;
    int status = QD_OK;

    FILE *coeffFile = NULL;
    
    size_t nread = 0;

    if (qcoeff0 == NULL || abs(dateAsYear - coeffYear) > QD_YEAR_UPDATE_INTERVAL)
    {
        coeffFile = fopen(filename, "r");
        if (coeffFile == NULL)
            return QD_FILE_READ;

        nread += fread(&nepoch, sizeof(nepoch), 1, coeffFile);
        nread += fread(&nmax, sizeof(nmax), 1, coeffFile);
        nread += fread(&mmax, sizeof(mmax), 1, coeffFile);
        nread += fread(&lmax, sizeof(lmax), 1, coeffFile);
        nread += fread(&nterm, sizeof(nterm), 1, coeffFile);
        if (nread != 5)
        {
            status = QD_FILE_READ;
            goto cleanup;
        }
        ntermsh =  mmax*(2*nmax - mmax + 1) + nmax + 1;

        void *mem = realloc(epochgrid, sizeof *epochgrid * nepoch);
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        epochgrid = mem;
        bzero(epochgrid, sizeof *epochgrid * nepoch);

        mem = realloc(coeff0, sizeof *coeff0 * (nterm * nepoch * 6));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        coeff0 = mem;
        bzero(coeff0, sizeof *coeff0 * (nterm * nepoch * 6));

        mem = realloc(qcoeff0, sizeof *qcoeff0 * (nterm * 3));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        qcoeff0 = mem;
        bzero(qcoeff0, sizeof *qcoeff0 * (nterm * 3));

        mem = realloc(gcoeff0, sizeof *gcoeff0 * (nterm * 3));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        gcoeff0 = mem;
        bzero(gcoeff0, sizeof *gcoeff0 * (nterm * 3));

        mem = realloc(xqcoeff, sizeof *xqcoeff * (ntermsh));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        xqcoeff = mem;
        bzero(xqcoeff, sizeof *xqcoeff * (ntermsh));

        mem = realloc(yqcoeff, sizeof *yqcoeff * (ntermsh));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        yqcoeff = mem;
        bzero(yqcoeff, sizeof *yqcoeff * (ntermsh));

        mem = realloc(zqcoeff, sizeof *zqcoeff * (ntermsh));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        zqcoeff = mem;
        bzero(zqcoeff, sizeof *zqcoeff * (ntermsh));

        mem = realloc(xgcoeff, sizeof *xgcoeff * (ntermsh));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        xgcoeff = mem;
        bzero(xgcoeff, sizeof *xgcoeff * (ntermsh));

        mem = realloc(ygcoeff, sizeof *ygcoeff * (ntermsh));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        ygcoeff = mem;
        bzero(ygcoeff, sizeof *ygcoeff * (ntermsh));

        mem = realloc(zgcoeff, sizeof *zgcoeff * (ntermsh));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        zgcoeff = mem;
        bzero(zgcoeff, sizeof *zgcoeff * (ntermsh));

        mem = realloc(polynomq, sizeof *polynomq * (lmax + 1));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        polynomq = mem;
        bzero(polynomq, sizeof *polynomq * (lmax + 1));
        polynomq[0] = 1.0;

        mem = realloc(polynomg, sizeof *polynomg * (lmax + 1));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        polynomg = mem;
        bzero(polynomg, sizeof *polynomg * (lmax + 1));
        polynomg[0] = 1.0;

        mem = realloc(sphericalharmonics, sizeof *sphericalharmonics * ntermsh);
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        sphericalharmonics = mem;
        bzero(sphericalharmonics, sizeof *sphericalharmonics * ntermsh);

        mem = realloc(anm, sizeof *anm * (nmax + 1) * (mmax + 1));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        anm = mem;
        bzero(anm, sizeof *anm * (nmax + 1) * (mmax + 1));

        mem = realloc(bnm, sizeof *bnm * (nmax + 1) * (mmax + 1));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        bnm = mem;
        bzero(bnm, sizeof *bnm * (nmax + 1) * (mmax + 1));

        mem = realloc(cm, sizeof *cm * (mmax + 1));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        cm = mem;
        bzero(cm, sizeof *cm * (mmax + 1));

        mem = realloc(dnm, sizeof *dnm * (nmax + 1) * (mmax + 1));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        dnm = mem;
        bzero(dnm, sizeof *dnm * (nmax + 1) * (mmax + 1));

        mem = realloc(en, sizeof *en * (nmax + 1) );
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        en = mem;
        bzero(en, sizeof *en * (nmax + 1));

        mem = realloc(marr, sizeof *marr * (mmax + 1));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        marr = mem;
        bzero(marr, sizeof *marr * (mmax + 1));

        mem = realloc(narr, sizeof *narr * (nmax + 1));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        narr = mem;
        bzero(narr, sizeof *narr * (nmax + 1));

        mem = realloc(pbar, sizeof *pbar * (nmax + 1) * (mmax + 1));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        pbar = mem;
        bzero(pbar, sizeof *pbar * (nmax + 1) * (mmax + 1));

        mem = realloc(vbar, sizeof *vbar * (nmax + 1) * (mmax + 1));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        vbar = mem;
        bzero(vbar, sizeof *vbar * (nmax + 1) * (mmax + 1));

        mem = realloc(wbar, sizeof *wbar * (nmax + 1) * (mmax + 1));
        if (mem == NULL)
        {
            status = QD_MEM;
            goto cleanup;
        }
        wbar = mem;
        bzero(wbar, sizeof *wbar * (nmax + 1) * (mmax + 1));

        nread = fread(epochgrid, sizeof *epochgrid, nepoch, coeffFile);
        if (nread != nepoch)
        {
            status = QD_FILE_READ;
            goto cleanup;
        }
        nread = fread(coeff0, sizeof *coeff0, (nterm * nepoch * 6), coeffFile);
        if (nread != (nterm * nepoch * 6))
        {
            status = QD_FILE_READ;
            goto cleanup;
        }

        // Access 3D fortran array var(i, j, k) as var[k * nj * ni + j * ni + i]
        coeffYear = dateAsYear;
        double year = coeffYear;
        if (year > epochgrid[nepoch - 1])
            year = epochgrid[nepoch - 1];

        int i1 = nepoch - 1;
        int i2 = nepoch - 1;
        double bottom = 1.0;
        if (coeffYear <= epochgrid[0])
        {
            year = epochgrid[0];
            i1 = 0;
            i2 = 0;
        }
        else if (coeffYear < epochgrid[nepoch - 1])
        {
            for (; i2 > 0 && coeffYear < epochgrid[i2]; i2--);
            i2++;
            i1 = i2 - 1;
            bottom = (double)(epochgrid[i2] - epochgrid[i1]);
        }
        double deltayear = year - epochgrid[i1];
        double interpFrac = deltayear / bottom;
        double a = 0;
        double we0 = (double)(epochgrid[i2] - coeffYear) / bottom;
        double we1 = 1.0 - we0;

        for (int icoord = 0; icoord < 3; icoord++)
        {
            for (int iterm = 0; iterm < nterm; iterm++)
            {
                a = coeff0[icoord * nepoch * nterm + i1 * nterm + iterm];
                qcoeff0[icoord * nterm + iterm] = a + (coeff0[icoord * nepoch * nterm + i2 * nterm + iterm] - a) * interpFrac;
                
                a = coeff0[(icoord + 3) * nepoch * nterm + i1 * nterm + iterm];
                gcoeff0[icoord * nterm + iterm] = a + (coeff0[(icoord + 3) * nepoch * nterm + i2 * nterm + iterm] - a) * interpFrac;
            }
        }

        status = alfBasisInit(nmax, mmax);
        if (status != QD_OK)
            goto cleanup;

    }

cleanup:

    if (coeffFile != NULL)
        fclose(coeffFile);

    return status;
}

void freeQuasiDipoleCoefficients(void)
{
    free(epochgrid);
    free(coeff0);
    free(qcoeff0);
    free(gcoeff0);
    free(xqcoeff);
    free(yqcoeff);
    free(zqcoeff);
    free(xgcoeff);
    free(ygcoeff);
    free(zgcoeff);
    free(polynomq);
    free(polynomg);
    free(sphericalharmonics);
    free(anm);
    free(bnm);
    free(cm);
    free(dnm);
    free(en);
    free(marr);
    free(narr);
    free(pbar);
    free(vbar);
    free(wbar);

    return;
}

int geographicToQuasiDipole(char *coeffFilename, double unixTime, double geodeticLatitude, double longitude, double altitudeKm, double *qdLatitude, double *qdLongitude)
{

    if (qdLatitude == NULL && qdLongitude == NULL)
        return QD_VOID_ARG;

    static double lastAltG = -100000.0;

    time_t t = (time_t)floor(unixTime);
    struct tm *tdata = gmtime(&t);
    double year = tdata->tm_year + 1900 + ((double)tdata->tm_yday + (double)tdata->tm_hour / 24.0) / 365.24;
    int status = initQuasiDipleCoefficients(coeffFilename, year);
    if (status != QD_OK)
        return status;

    // do the calculations
    if (altitudeKm != lastAltG)
    {
        double rho = Re / (Re + altitudeKm);
        for (int l = 1; l <= lmax; l++)
            polynomq[l] = polynomq[l-1]*rho;
        int iterm = 0;
        for (int itermsh = 0; itermsh < ntermsh; itermsh++)
        {
            xqcoeff[itermsh] = 0;
            yqcoeff[itermsh] = 0;
            zqcoeff[itermsh] = 0;
            for (int l = 0; l <= lmax; l++)
            {
                iterm = l*ntermsh + itermsh;
                xqcoeff[itermsh] = xqcoeff[itermsh] + qcoeff0[0 * nterm + iterm]*polynomq[l];
                yqcoeff[itermsh] = yqcoeff[itermsh] + qcoeff0[1 * nterm + iterm]*polynomq[l];
                zqcoeff[itermsh] = zqcoeff[itermsh] + qcoeff0[2 * nterm + iterm]*polynomq[l];
            }
        }
        lastAltG = altitudeKm;
    }
    double phi = longitude * M_PI / 180.0;
    double theta = (90.0 - geodeticLatitude) * M_PI / 180.0;

    status = quasiDipoleSphericalHarmonics(theta, phi);
    if (status != QD_OK)
        return status;

    double xq = dotprod(sphericalharmonics, xqcoeff, ntermsh);
    double yq = dotprod(sphericalharmonics, yqcoeff, ntermsh);
    double zq = dotprod(sphericalharmonics, zqcoeff, ntermsh);

    double qlon = atan2(yq,xq);
    double cosqlon = cos(qlon);
    double sinqlon = sin(qlon);
    double qlat = atan2(zq,sqrt(xq*xq + yq*yq));
    
    if (qdLatitude != NULL)
        *qdLatitude = qlat * 180.0 / M_PI;

    if (qdLongitude != NULL)
        *qdLongitude = qlon * 180.0 / M_PI;

    return status;
}

double quasiDipoleMagneticLocalTime(char *coeffFilename, double unixTime, double qdLatitude, double qdLongitude, double *mlt)
{
    if (coeffFilename == NULL || mlt == NULL)
        return QD_VOID_ARG;

    int status = QD_OK; 

    // See Landal and Richmond, Space Sci. Rev., 2017, 206:27-59.
    // https://doi.org/10.1007%2Fs11214-016-0275-y

    time_t t = (time_t)floor(unixTime);

    struct tm *tdata = gmtime(&t);
    double year = tdata->tm_year + 1900 + tdata->tm_yday / 365.24;

    // Any estimate of MLT is approximate
    // Using QD longitude of subsolar point at ~10 Re as an approximation for 
    // centered-dipole longitude of subsolar point
    double diffHours = solarTimeDifferenceHours(year);
    double utHours = tdata->tm_hour + tdata->tm_min / 60.0 + tdata->tm_sec / 3600.0;
    double apparentSolarTime = utHours + diffHours;
    // Update latitude based on solar declination
    double latitude = solarDeclinationAnglePSA(unixTime);
    double longitude = (apparentSolarTime - 12.0) * 15.0;
    double qdlatitudeSubsolarPoint = 0.0;
    double qdlongitudeSubsolarPoint = 0.0;
    status = geographicToQuasiDipole(coeffFilename, unixTime, latitude, longitude, 64000.0, &qdlatitudeSubsolarPoint, &qdlongitudeSubsolarPoint);
    if (status != QD_OK)
        return status;

    *mlt = (qdLongitude - qdlongitudeSubsolarPoint) / 15.0 + 12.0;
        if (*mlt < 0)
            *mlt = *mlt + 24.0;
        else if (*mlt > 24.0)
            *mlt = *mlt - 24.0;

    return status;

}

// Ref "PSA": Blanco-Muriel, M., Alarcón-Padilla, D. C., López-Moratalla, T., & Lara-Coira, M. (2001). Computing the solar vector. Solar energy, 70(5), 431-441.
// PSA Eq. 1
double julianDayPSA(double unixTime)
{
    time_t t = (time_t)floor(unixTime);
    struct tm *dt = gmtime(&t);
    int year = dt->tm_year + 1900;
    int month = dt->tm_mon + 1;
    int day = dt->tm_mday;
    double hour = (double)dt->tm_hour;
    double min = (double)dt->tm_min;
    double sec = (double)dt->tm_sec;
    hour += min / 60. + (sec + (unixTime - (double)t)) / 3600.0;

    long julianDayInt = (1461 * (year + 4800 + (month-14)/12)) / 4 + (367*(month - 2 -12*((month-14)/12))) / 12 - (3*((year + 4900 + (month-14)/12)/100)) / 4 + day - 32075;
    double julianDay = (double)julianDayInt - 0.5 + hour / 24.0;

    return julianDay;
}

double solarTimeDifferenceHours(double dateAsYear)
{
    // From approximation at https://en.wikipedia.org/wiki/Equation_of_time
    double n = 2.0 * M_PI / 365.24;
 
    double day = (dateAsYear - floor(dateAsYear)) * 365.24;
    double intDay = day - floor(day);
    double a = (intDay + 9) * n;
    double b = a + 0.0167 * 2.0 * sin((intDay - 3) * n);
    double c = (a - atan(tan(b) / cos(23.44 * M_PI / 180.0))) / M_PI;
    double timeDifferenceMinutes = 720.0 * (c - (int)(c+0.5));

    return timeDifferenceMinutes / 60.0;
}

double solarDeclinationAnglePSA(double unixTime)
{
    // PSA Eq 2
    double n = julianDayPSA(unixTime) - 2451545.0;
    // PSA Eq 3
    double omega = 2.1429 - 0.0010394594 * n;
    // PSA Eq 4
    double ml = 4.8950630 + 0.017202791698 * n;
    // PSA Eq 5
    double g = 6.2400600 + 0.0172019699 * n;
    // PSA Eq 6
    double el = ml + 0.03341607 * sin(g) + 0.00034894 * sin(2.0 * g) - 0.0001134 - 0.0000203 * sin(omega);
    // PSA Eq 7
    double ep = 0.4090928 - 6.2140e-9 * n + 0.0000396 * cos(omega);

    // PSA Eq 9
    double declination = asin(sin(ep) * sin(el)) * 180.0 / M_PI;

    return declination;

}

int quasiDipoleToGeographic(char *coeffFilename, double unixTime, double qdLatitude, double qdLongitude, double altitudeKm, double *geodeticLatitude, double *longitude)
{
    if (geodeticLatitude == NULL && longitude == NULL)
        return QD_VOID_ARG;

    static double lastAltQ = -100000.0;    

    time_t t = (time_t)floor(unixTime);
    struct tm *tdata = gmtime(&t);
    double year = tdata->tm_year + 1900 + ((double)tdata->tm_yday + (double)tdata->tm_hour / 24.0) / 365.24;
    int status = initQuasiDipleCoefficients(coeffFilename, year);
    if (status != QD_OK)
        return status;

    // do the calculations
    if (altitudeKm != lastAltQ)
    {
        double rho = Re / (Re + altitudeKm);
        for (int l = 1; l <= lmax; l++)
            polynomg[l] = polynomg[l-1]*rho;
        int iterm = 0;
        for (int itermsh = 0; itermsh < ntermsh; itermsh++)
        {
            xgcoeff[itermsh] = 0;
            ygcoeff[itermsh] = 0;
            zgcoeff[itermsh] = 0;
            for (int l = 0; l <= lmax; l++)
            {
                iterm = l*ntermsh + itermsh;
                xgcoeff[itermsh] = xgcoeff[itermsh] + gcoeff0[0 * nterm + iterm]*polynomg[l];
                ygcoeff[itermsh] = ygcoeff[itermsh] + gcoeff0[1 * nterm + iterm]*polynomg[l];
                zgcoeff[itermsh] = zgcoeff[itermsh] + gcoeff0[2 * nterm + iterm]*polynomg[l];
            }
        }
        lastAltQ = altitudeKm;
    }
    double phi = qdLongitude * M_PI / 180.0;
    double theta = (90.0 - qdLatitude) * M_PI / 180.0;

    status = quasiDipoleSphericalHarmonics(theta, phi);
    if (status != QD_OK)
        return status;

    double xg = dotprod(sphericalharmonics, xgcoeff, ntermsh);
    double yg = dotprod(sphericalharmonics, ygcoeff, ntermsh);
    double zg = dotprod(sphericalharmonics, zgcoeff, ntermsh);

    double glon = atan2(yg,xg);
    double glat = atan2(zg,sqrt(xg*xg + yg*yg));
    
    if (geodeticLatitude != NULL)
        *geodeticLatitude = glat * 180.0 / M_PI;

    if (longitude != NULL)
        *longitude = glon * 180.0 / M_PI;

    return status;

}


int quasiDipoleSphericalHarmonics(double theta, double phi)
{
    if (pbar == NULL)
        return QD_MEM;

    int status = QD_OK;

    status = alfBasis(nmax, mmax, theta);
    if (status != QD_OK)
        return status;

    double mphi = 0;
    double cosmphi = 0;
    double sinmphi =0;
    
    status = alfBasis(nmax,mmax,theta);
    if (status != QD_OK)
        return status;

    int32_t i = 0;
    for (int32_t n = 0; n <= nmax; n++)
    {
        sphericalharmonics[i] = pbar[0*nmax + n];
        i++;
    }
    for (int32_t m = 1; m <= mmax; m++)
    {
        mphi = (double)m * phi;
        cosmphi = cos(mphi);
        sinmphi = sin(mphi);
        for (int32_t n = m; n <= nmax; n++)
        {
            sphericalharmonics[i] = pbar[m*nmax + n] * cosmphi;
            sphericalharmonics[i+1] = pbar[m*nmax + n] * sinmphi;
            i += 2;
        }
    }

    return status;
}

// from Emmert and Richmond
int alfBasisInit(int32_t nmax0in, int32_t mmax0in)
{
    int32_t nmax0 = nmax0in;
    int32_t mmax0 = mmax0in;
    
    if (narr == NULL)
        return QD_MEM;

    for (int64_t n = 1; n <= nmax0; n++)
    {
        narr[n] = (double)n;
        en[n] = sqrt((double)(n*(n+1)));
        anm[0 * nmax + n] = sqrt((double)((2*n-1)*(2*n+1))) / narr[n];
        bnm[0 * nmax + n] = sqrt((double)((2*n+1)*(n-1)*(n-1)) / (double)(2*n-3)) / narr[n];
    }

    for (int64_t m = 1; m <= mmax0; m++)
    {
        marr[m] = (double)m;
        cm[m] = sqrt((double)(2*m+1)/(double)(2*m));
        for (int64_t n = m+1; n <= nmax0; n++)
        {
            anm[m * nmax + n] = sqrt((double)((2*n-1)*(2*n+1)) / (double)((n-m)*(n+m)));
            bnm[m * nmax + n] = sqrt((double)((2*n+1)*(n+m-1)*(n-m-1)) / (double)((n-m)*(n+m)*(2*n-3)));
            dnm[m * nmax + n] = sqrt((double)((n-m)*(n+m)*(2*n+1)) / (double)(2*n-1));
        }
    }

    return QD_OK;
}

int alfBasis(int32_t nmax, int32_t mmax, double theta)
{
    if (pbar == NULL)
        return QD_MEM;


    pbar[0] = 0.70710678118654746;
    double x = cos(theta);
    double y = sin(theta);
    for (int32_t m = 1; m <= mmax; m++)
    {
      wbar[m*nmax + m] = cm[m] * pbar[(m-1)*nmax + (m-1)];
      pbar[m*nmax + m] = y * wbar[m*nmax + m];
      for(int32_t n = m+1; n <= nmax; n++)
      {
        wbar[m*nmax + n] = anm[m*nmax + n] * x * wbar[m*nmax + (n-1)] - bnm[m*nmax + n] * wbar[m*nmax + (n-2)];
        pbar[m*nmax + n] = y * wbar[m*nmax + n];
        vbar[m*nmax + n] = narr[n] * x * wbar[m*nmax + n] - dnm[m*nmax + n] * wbar[m*nmax + (n-1)];
        wbar[m*nmax + (n-2)] = marr[m] * wbar[m*nmax + (n-2)];
      }
      wbar[m*nmax + (nmax-1)] = marr[m] * wbar[m*nmax + (nmax-1)];
      wbar[m*nmax + nmax] = marr[m] * wbar[m*nmax + nmax];
      vbar[m*nmax + m] = x * wbar[m*nmax + m];
    }
    pbar[0 * nmax + 1] = anm[0 * nmax + 1] * x * pbar[0];
    vbar[0*nmax + 1] = -en[1] * pbar[1*nmax + 1];
    for (int32_t n = 2; n <= nmax; n++)
    {
      pbar[0*nmax + n] = anm[0*nmax + n] * x * pbar[0*nmax + (n-1)] - bnm[0*nmax + n] * pbar[0*nmax + (n-2)];
      vbar[0*nmax + n] = -en[n] * pbar[1*nmax + n];
    }

    return QD_OK;
}

double dotprod(double *a, double *b, size_t len)
{
    if (a == NULL || b == NULL)
        return nan("");

    double sum = 0;
    for (size_t i = 0; i < len; i++)
        sum += a[i] * b[i];

    return sum;
}
